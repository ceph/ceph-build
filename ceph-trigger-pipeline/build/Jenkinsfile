/*
This pipeline's role is to:
  1. Be triggered by a git push event
  2. Build one or more sets of parameters
  3. For each set, trigger a second job or pipeline with those parameters

Parameter sets are constructed in this way:
  1. Initialized from a base set of default values
  2. Extended by values parsed from git trailers
    a. See https://git-scm.com/docs/git-interpret-trailers
  3. For builds that will trigger jobs other than ceph-dev-pipeline, also extended by values determined by examining the branch name
*/
import groovy.json.JsonBuilder

def pretty(obj) {
  return new JsonBuilder(obj).toPrettyString()
}

// These parameters are able to be parsed from git trailers
def gitTrailerParameterNames = [
  "CEPH_BUILD_BRANCH",
  "CEPH_BUILD_JOB",
  "ARCHS",
  "CI_COMPILE",
  "CI_CONTAINER",
  "CI_PIPELINE",
  "DISTROS",
  "DWZ",
  "FLAVOR",
  "SCCACHE",
]
// These are the default parameter values for the pipeline
def defaults = [
  'CEPH_BUILD_JOB': 'ceph-dev-new',
  'DISTROS': 'centos9 jammy windows',
  'ARCHS': 'x86_64 arm64',
  'FLAVOR': 'default',
]
// This will later hold the initial set of parameters, before any branch-based
// values are inserted.
def initialParams = [:]
// This will later hold one or more parameter sets. Each parameter set will
// result in a triggered job.
def paramMaps = []
// This will later hold the build's description; we need to store it so that
// we can append to it later, as there is no way to read it.
def description = "";

// This encodes the same logic as the ceph-dev-new-trigger job.
// It returns a list of one or more parameter sets.
def params_from_branch(branch, initialParams) {
  def params = [initialParams.clone()]
  switch (branch) {
    case ~/.*reef.*/:
      break
    case ~/.*squid.*/:
      break
    case ~/.*tentacle.*/:
      params.push(params[0].clone())
      params[1]['ARCHS'] = 'x86_64'
      params[1]['DISTROS'] = 'centos9'
      params[1]['FLAVOR'] = 'crimson'
      break
    case ~/.*centos9-only.*/:
      break
    case ~/.*crimson-only.*/:
      params[0]['ARCHS'] = 'x86_64'
      params[0]['DISTROS'] = 'centos9'
      params[0]['FLAVOR'] = 'crimson'
      break
    case ~/.*jaeger.*/:
      params[0]['ARCHS'] = 'x86_64'
      params[0]['DISTROS'] = 'centos8 focal'
      params[0]['FLAVOR'] = 'jaeger'
      break
    default:
      params.push(params[0].clone())
      params[1]['ARCHS'] = 'x86_64'
      params[1]['DISTROS'] = 'centos9'
      params[1]['FLAVOR'] = 'crimson'
  }
  return params
}

pipeline {
  agent any
  stages {
    stage("Prepare initial parameters") {
      steps {
        script {
          initialParams.BRANCH = env.ref.replace("refs/heads/", "")
          initialParams.putAll(defaults)
          println("BRANCH=${initialParams.BRANCH}")
        }
        script {
          println("SHA1=${env.head_commit_id}")
        }
        script {
          println("pusher=${env.pusher}")
        }
        script {
          println("Looking for git trailer parameters: ${gitTrailerParameterNames}")
          def trailer = sh(
            script: "echo \"$head_commit_message\" | git interpret-trailers --parse",
            returnStdout: true,
          )
          println("trailer: ${trailer}")
          for (item in trailer.split("\n")) {
            def matcher = item =~ /(.+): (.+)/
            if (matcher.matches()) {
              key = matcher[0][1].replace("-", "_").toUpperCase()
              value = matcher[0][2]
              if ( key in gitTrailerParameterNames && value ) {
                initialParams[key] = value
              }
            }
          }
        }
        script {
          println("Initial parameters: ${pretty(initialParams)}")
          initialParams.each { key, value -> description += "${key}=${value}<br />" }
          buildDescription description
        }
      }
    }
    stage("Prepare final parameters") {
      steps {
        script {
          if ( initialParams.CEPH_BUILD_JOB == "ceph-dev-pipeline" ) {
            paramMaps = [initialParams]
          } else {
            paramMaps = params_from_branch(initialParams.BRANCH, initialParams)
          }
        }
        script {
          println("Final parameters: ${pretty(paramMaps)}")
        }
      }
    }
    stage("Trigger job") {
      steps {
        script {
          for (paramsMap in paramMaps) {
            // Before we trigger, we need to transform the parameter sets from
            // the base Groovy types into the types expected by Jenkins
            def paramsList = []
            paramsMap.each {
              entry -> paramsList.push(string(name: entry.key, value: entry.value))
            }
            def job = paramsMap.CEPH_BUILD_JOB
            println("triggering: ${pretty(paramsMap)}")
            // triggeredBuild = build(
            //   job: JOB,
            //   parameters: params,
            //   wait: false,
            //   waitforStart: true,
            // )
            // def buildId = triggeredBuild.getId()
            def buildId = "_ID_"
            def buildUrl = new URI([env.JENKINS_URL, "job", job, buildId].join("/")).normalize()
            buildDescription """\
              ${description}<br />
              <a href="${buildUrl}">${job} ${buildId}</a>
            """
          }
        }
      }
    }
  }
}
